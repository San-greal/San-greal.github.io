## 智能指针

### 基本概念与规则

- Rust语言的资源管理采用**所有权**的方式进行管理
- 一个对象只有一个所有者，跟踪所有者的**生存期**，从而对对象的使用安全性进行控制
- 赋值语句具有转移语义：将一个对象赋值给一个变量，新变量获得该变量的所有权
- 引用：
  1. 共享引用
  2. 可变引用

### 用于理解概念的故事

- 我买了一本书，我拥有该书的**所有权**，我是该书的**所有者**

- 我把书送（转移/赋值）给我妹，我妹拥有了该书的**所有权**，我妹是该书的**所有者**

- 经常有人找我妹借这本书看：

  - 书一次只能借给一个人看，有人不开心，于是使用魔镜（**引用**）
    - 普通魔镜（**共享引用**&T）：有很多普通魔镜，可以看书的内容，但不可以在书上修改
    - 特权魔镜（**可变引用**&mut T）：**唯一**一把特权魔镜，可以看书的内容，可以在书上修改
    - 特权魔镜和普通魔镜不可以同时借出，也就是说如果已经有人在使用普通魔镜，特权魔镜不借，如果特权魔镜已经借出，普通魔镜不借

- 强化版普通魔镜（**RefCell<T>**与**Cell<T>**）：是一个容器，在其内部包含的东西都可以在**共享引用**的状态下被修改，这种现象被称为**内部可变性**（Rust特许的），与**承袭可变性**相对应

  1. 代码示例：

  2. ```rust
     fn main() {
       let mut data = 100_i32;
       let p : &i32 = &data;
       data = 10;
       println!("{}", *p);
     }
     ```

     结果：

     ```
     error: cannot assign to `data` because it is borrowed
     ```

  3. Rust的设计思路就是，alias和mutation不能共存。这段代码中，我们通过两个变量绑定使得data和p访问同一块内存区域，因此存在alias，所以我们不能同时提供mutation，使用data来改变变量是有可能出问题的。但是此例不涉及内存的分配和释放，这里的读写操作都在我们的控制之中，我们希望有一个指针指向我们关心的内容，而这个内容可能发生变化，Rust编译器却不让我们通过。

  4. 一个变量是否是可变的，取决于是否用mut修饰那个变量绑定。可变还是不可变取决于变量的使用方式。这就叫做**承袭可变性**

  5. 代码示例：

  6. ```rust
     use std::cell::Cell;
     
     fn main() {
       let data : Cell<i32> = Cell::new(100);
       let p = &data;
       data.set(10);
       println!("{}", p.get());
     
       p.set(20);
       println!("{:?}", data);
     }
     ```

     结果：通过

  7. 这个例子与上一个版本的对比，除了把data的类型改为Cell<i32>，读写操作换成了get set函数之外，还有更重要的区别。需要注意的是这里的“可变性”问题，跟我们前面见到的情况不一样了。data这个变量绑定，没有用mut修饰，p这个指针，也没有用&mut修饰，然而不可变引用竟然可以调用set函数，改变了变量的值，而且还没有出现编译错误。虽然粗略一看，Cell类型似乎违反了Rust的“唯一修改权”原则。但实际上，这个类型是完全符合“内存安全”的。为什么Rust要尽力避免 alias 和 mutation 同时存在？因为假如说，我们同时有**可变指针**和**不可变指针**指向同一块内存，有可能出现通过一个可变指针修改内存的过程中，数据结构处于被破坏状态的情况下，被其它的指针观测到了。Cell类型是不会出现这样的情况的。因为Cell类型包裹的数据必须具有Copy属性，这意味着每次get set函数的调用都是执行的一次完整的数据拷贝操作。每次get set函数调用之后，Cell类型的内部都处于一个正确的状态。我们不可能在set执行了一半的时候，再同时调用get。由此可见，Cell类型的行为，和Rust中我们以前见到的其它类型的行为是不一致的。但这个不一致是可以容许的。因为我们会发现，Cell类型的行为是完全符合“内存安全”的，只是它不符合Rust基本的“alias+mutation”规则限制，它是通过API设计来保证的内存安全。**它是对“alias+mutation”规则的有益补充，而非完全颠覆。**

### 多种智能指针

1. 首先，Rc类型和 & 型引用一样，提供了“共享性”。它可以允许多个指针指向同一块内存。因此它必然不能提供“可变性”。它没有违反我们前面讲的“内存安全”原则，它没有设计直接修改内部数据的成员方法，每个所有者对内部数据只有只读功能，因此，它是安全的。其次，它是“线程局部”(Thread Local)的，我们不可能创造两个分属于不同线程的Rc指针指向同一个内存区域。

   Rc指针是没有实现Copy trait的，如果使用直接赋值方式，那么会执行move语义，导致前一个指针从此失效，后一个指针开始起作用，而且引用计数值不变。如果需要创造新的Rc指针，必须手工调用clone()函数，此时引用计数值才会加1。当某个Rc指针失效时，会导致引用计数值减一。当引用计数值减到0的时候，共享内存空间才会被释放。

   **这个 Rc 类型，它的实现原理，必须基于“内部可变性”。**

   这个 Rc<T> 指针的原理是什么？它指向的内容，不仅包括了在堆上分配的 T 类型的变量，而且还（至少）包括一个整数类型的引用计数值。标准库中的实现方式，其实包括了两个整数值，一个表示强引用的个数，一个表示弱引用的个数。每次调用 Rc::clone(&self) 方法的时候，我们不仅要把指针本身复制一份，还要把指向的计数值加一。但是，Rc指针并未提供可变性，我们怎么才能使用一个没有写权限的指针，修改它所指向的值呢？**所以，这个计数值，本身必须具备“内部可变性”**，此时，使用 Cell<usize> 类型就是非常合适的。

2. Cell类型的使用是有一定局限性的。因为它要求内部数据类型必须具有Copy属性。**如果我们希望给不具备Copy属性的内部成员变量提供“内部可变性”，那就可以使用RefCell。**

   从原理上来说，Rust的默认的“借用规则检查器”，它的逻辑非常像是一个在编译阶段执行的“读写锁(read-write-locker)”。如果同时存在多个“读”的锁，是没问题的；如果同时存在“读”和“写”的锁，或者同时存在多个“写”的锁，就会发生错误。**我们的RefCell类型并没有打破这个规则，只不过，它把这个检查逻辑从编译阶段，移到了执行阶段。**



### 泛型与关联类型

1. 泛型：

   ```rust
   trait Generic<T> {
       fn get(&self) -> T;
   }
   ```

2. 关联类型：

   ```rust
   trait Associated {
       type T;
       fn get(&self) -> Self::T;
   }
   ```

3. 泛型允许你实现数量众多的具体traits(通过改变T来支持不同类型)，例如之前提到过的From<T> trait，我们可以实现任意数量类型。举例来看，假设你有一个类型定义：MyNumeric。你可以在此类型上实现 From<u8>, From<u16>, From<u32>等多种数据转换。这使得泛型在处理仅是类型参数不同的trait时特别有用。

4. 关联类型仅允许 **单个实现**，因为一个类型仅能实现一个trait一次，这可以用来限制实现的数量。Deref trait有一个关联类型：Target，用于解引用到目标类型。如果可以解引用到多个不同类型，会使人相当迷惑（对编译类型推导也很不友好）。

### 解引用与引用

1. “解引用(Deref)”是“引用(Ref)”的反操作。比如说，我们有引用类型let p: &T;，那么可以用*符号执行解引用操作，let v: T = *p;。如果p的类型是&T， 那么*p的类型就是T。

2. 自定义解引用：

   1. 实现标准库中的std::ops::Deref和std::ops::DerefMut这两个 trait

   2. Deref与DerefMut的定义（两者的返回值不同而已）：

      ```rust
      pub trait Deref {
          type Target: ?Sized; //Target关联类型，代表解引用后的目标类型
          fn deref(&self) -> &Self::Target;
      }
      
      pub trait DerefMut: Deref {
          fn deref_mut(&mut self) -> &mut Self::Target;
      }
      ```

   3. 标准库中实现了String向str的解引用转换：

      ```rust
      impl ops::Deref for String {
          type Target = str; //关联类型
      
          #[inline]
          fn deref(&self) -> &str {
              unsafe { str::from_utf8_unchecked(&self.vec) }
          }
      }
      ```
      
   4. 关系图：

      ```
      s         : String
      &s        : &String
      Target    : str
      s.deref() : &str
      *s        : str
      &*s       : &str
      请大家注意这里的类型，deref() 方法返回的类型是 &Target，而不是 Target。如果说有变量s的类型为String，*s 的类型并不等于 s.deref() 的类型。
      *s的类型实际上是 Target，即str。&*s的类型为&str。而 s.deref() 的类型为 &Target，即 &str。
      ```

   5. 智能指针：

      - &[T]是指针，指向一个数组切片；
      - &str是“指针”，指向一个字符串切片；
      - Box<T>是“指针”，指向一个在堆上分配的对象；
      - Vec<T>是“指针”，指向一组同类型的顺序排列的堆上分配的对象；
      - String是“指针”，指向的是一个堆上分配的字节数组，其中保存的内容是合法的 utf8 字符序列。
      - Rc<T>和Arc<T>也算是某种形式的“指针”，它们提供的是一种“共享”的所有权，当所有的引用计数指针都销毁之后，它们所指向的内存空间才会被释放。

3. 自动解引用

   1. 什么是自动解引用：

      ```rust
      fn main() {
          let s = "hello";
          println!("length: {}", s.len());
          println!("length: {}", (&s).len());
          println!("length: {}", (&&&&&&&&&&&&&s).len());
      }
      ```

      编译发现，可以编译成功。我们知道，len这个方法的签名是：

      ```rust
      fn len(&self) -> usize
      ```

      它接受的参数是&str，因此我们可以用 UFCS 语法这么调用：

      ```rust
      println!("length: {}", str::len(&s));
      ```

      但是，我们如果使用&&&&&&&&&&str类型来调用成员方法，也是可以的。原因就是，Rust编译器帮我们做了隐式的 deref 调用，当它找不到这个成员方法的时候，它会自动尝试使用deref方法后再找该方法，一直循环下去。编译器在&&&str类型里面找不到len方法，就尝试将它deref，变成&&str类型，再寻找len方法，还是没找到，那么继续deref，变成&str，现在找到len方法了，于是就调用这个方法。

   2. 自动解引用的用处：

      1. Rc实现的Deref：

         ```rust
         impl<T: ?Sized> Deref for Rc<T> { //类型长度不固定
             type Target = T;
         
             #[inline(always)] //这在编译时起到了优化的效果，虽然具体的我还不太懂
             fn deref(&self) -> &T {
                 &self.inner().value
             }
         }
         ```

         它的 Target 类型是它的泛型参数 T。

         ```rust
         use std::rc::Rc;
         
         fn main() {
             let s = Rc::new(String::from("hello"));
             println!("{:?}", s.bytes());
         }
         ```

         Rc类型本身并没有bytes()方法，所以编译器会尝试自动deref，试试s.deref().bytes()。String类型其实也没有bytes()方法，但是String可以继续deref，于是再试试s.deref().deref().bytes()。这次在str类型中，找到了bytes()方法，于是编译通过。我们实际上通过Rc类型的变量，调用了str类型的方法，让这个智能指针像个透明的存在。这就是自动Deref的意义。

4. 手动处理解引用

   1. 智能指针中的方法与它内部成员的方法冲突怎么办？编译器会优先调用当前最匹配的类型，而不会执行自动 deref，这种情况下，我们就只能手动 deref 来表达我们的需求了。比如说，Rc类型和String类型都有clone方法，但是它们执行的任务不同。Rc::clone()做的是把引用计数指针复制一份，把引用计数加1。String::clone()做的是把字符串复制一份。示例如下：use std::rc::Rc;

      ```rust
      use std::rc::Rc;
      use std::ops::Deref;
      
      fn type_of(_: ()) { }
      
      fn main() {
          let s = Rc::new(Rc::new(String::from("hello")));
      
          let s1 = s.clone();        // 类型为Rc<Rc<String>>
          //type_of(s1);
          let ps1 = (*s).clone();    // 类型为Rc<String>
          //type_of(ps1);
          let pps1 = (**s).clone();  // 类型为String
          //type_of(pps1);
      }
      ```
      一般情况，在函数调用的时候，编译器会帮我们尝试自动解引用。但在其它情况下，编译器不会为我们自动插入自动解引用的代码。比如，以String和 &str类型为例：

      ```rust
      fn main() {
        let s = String::new();
        match &s {
          "" => {}
          _ => {}
        }
      }
      ```

      解决方法：

      ```
      match s.as_ref()。 这个方法是最通用最直观的办法。
      match s.borrow()。为了使用这个方法，我们必须引入Borrow trait。也就是需要加上代码use std::borrow::Borrow;。
      match s.deref()。 这个方法通过主动调用deref()方法，达到类型转换的目的。此时我们需要引入Deref trait方可以通过编译，即加上代码use std::ops::Deref;。
      match &*s。 我们可以通过*s运算符，也可以强制调用deref()方法，与上面的做法一样。
      match &s[..]。这个方案也是可以的，这里利用了String重载的Index操作。
      ```

   2. *与Deref的关系（容易混淆）：

      ```rust
      use std::rc::Rc;
      use std::ops::Deref;
      
      fn main() {
          let s = Rc::new(String::from("hello"));
      
          println!("length: {}", s.len());
          println!("length: {}", s.deref().len());
          println!("length: {}", s.deref().deref().len());
      
          println!("length: {}", (*s).len());
          println!("length: {}", (&*s).len());
          println!("length: {}", (&**s).len());
      }
      ```

      String的默认deref方法如下：

      ```rust
      impl ops::Deref for String {
          type Target = str;
      
          #[inline]
          fn deref(&self) -> &str {
              unsafe { str::from_utf8_unchecked(&self.vec) }
          }
      }
      ```

      



