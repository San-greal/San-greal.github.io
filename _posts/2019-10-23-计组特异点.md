---
layout:     post
title:      计组特异点
subtitle:   
date:       2019-10-23
author:     度朝腾
catalog: true
tags:
    - 计组
---

### 一、定点数的表示与运算

1. 47-2：这种题其实并不是考察定点数的乘法运算，在这种题使用乘法运算极度吃亏，相反，考察的是定点数的表示范围，通过转化成十进制，并搞清楚定点数表示的十进制范围，然后通过比较从而判断是否溢出。

2. 47-3：这题考察了大/小端地址以及数据边界对齐的问题，具体的可以查看178页的解释，注意这道题目中的字节分配，可以看答案明白

3. 48-10：这道题目考察的是对于 0 这个比较特殊的情况，原码、反码、补码和移码的区别，从而根据 0 所存在的形式数量，判断不同数据的存在数量：

   1. 原码[+0] = 00000 和 [-0] = 10000
   2. 补码[+0] = [-0] = 0.0000
   3. 反码[+0] = 0.0000 和 [-0] = 1.1111
   4. 移码[+0] = [-0] = 10000

4. 48-11：考察定点数范围以及你对它的熟练度，知道为什么，才能做，这个我建议去看

   [定点数表示范围分析]: https://www.jianshu.com/p/4bcf48987c1f

5. 49-20：这个描述把我坑了，补码与移码的 0 各自表示时当然唯一，但是它们之间相互比较自然不一样

6. 47-28：这道题比较特别，主要是B选项的问题，x 为正数只是充分条件，比如说 x = 0 就打破了这个当且仅当条件，另外需要注意的是，补码的表示形式全部唯一

7. 50-29：这他娘考的就是符号扩展

8. 50-32：你都不知道模4补码是啥？书上41面，双符号位也称模4补码，具体理解可以看

   [模4补码]: https://www.zybang.com/question/8aef3eaf78e5fa54c98c36fa43c63084.html

   要注意的是，存储模4补码只需要一个符号位，因为任何一个正确的数值，模4补码的两个符号位都是相同的

9. 50-35：注意题目的表述，默认认为描述 -0 这种就是原码和反码了

10. 51-42：考察溢出的判断条件，如果再次出错，建议重新观看42页

11. 51-45：描述很奇怪，之后可能还需要判断，这个描述看来，它给你的是什么，本身的机器码就是什么，而且本身还考察了溢出的判断问题

12. 52-54：在计算机中，主存地址主要都是用无符号数表示，因为主存地址都是正数所以不需要符号位

13. 52-58：这他娘考的就是符号扩展，别想多了

14. 52-59：搞清楚逻辑移位与算术移位的区别

15. 53-2：你需要知道的是，这些转换来转换去，机器码本身是不变的，变化的只是对机器码的解释

16. 54-6：变形补码又称之为双符号位，也叫模4补码

### 二、浮点数的表示与运算

1. 66-6：错的知识点都差不多，需要知道的是，阶码位数越多表示的数范围越大，尾数位数越多表示的精度越高

2. 66-7： ![img](https://gss0.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=c43f37c163224f4a57cc7b1539c7bc6a/024f78f0f736afc30ff57e82bd19ebc4b645125f.jpg) 

   ​		这道题就是没搞清楚基数是啥，基数就是这里面的2咯，一般来说是默认为2，当然，可能改成别的考，另外

   存在几个还没搞清楚咋回事的东西：

   - 基数越大，在运算中尾数右移的可能性越小，运算的精度损失越小
   - 基数大时发生因对阶或尾数溢出需右移及规格化需左移的次数显著减少，运算速度可以提高
   - 基数越大，可以表示的数越多
   - 基数越大，范围越大，但精度变小（数变稀疏，因为乘的时候范围变大了，所以变稀疏了（离散了））

3. 67-10：注意，IEEE 754的规则是隐藏了那一个1，但是你自己的规定没说隐藏，所以你懂的

4. 67-11：没有搞清楚为什么要进行浮点数规格化，其实是为了提高精度的同时，保证数据的唯一性， 在计算机内，对非0值的浮点数，要求尾数的绝对值必须大于基数的倒数（默认小于等于1），这就要求尾数的最高有效位是1，满足这种表示要求的浮点数称为规格化表示，不满足条件的就需要规格化咯。 **按规格化的定义-1/2确实应该是算规格化数，但是在机器实际判断规格化与否（以补码为例）是根据符号位与有效位最高位是否不同老判断的，即认为符号位与有效位最高位不同时才是规格化数，所以-1/2又不算规格化数，而根据定义-1本来不算规格化数，但其补码表示为11.0000，机器识别其是规格化数，所以应该是要站在机器判断的角度看，这两个是特殊情况**，另外这道题a选项有个小问题，就是它现在是补码，你必须先把它化成原码再取绝对值 

5. 67-14：注意国际标准中的尾数编码是原码！

6. 68-29、30、31：定点数是没有舍入概念的，别瞎搞；浮点数舍入有两种情况，对阶和右规格化；舍入不一定产生误差，比如说11.00 -> 11.0就没有产生误差；想要具体搞清楚这几道题，我们需要知道什么是溢出：

   1. 阶码上溢：一个正指数超过了最大允许值时，浮点数发生上溢，若结果是正数，发生正上溢出，若结果是负数，发生负上溢出。这种情况为软件故障，通常要引入溢出故障处理程序处理
   2. 阶码下溢：一个负指数比最小允许值还小时，浮点数发生下溢出。一般机器把下溢出时的值置为0，不发生溢出故障
   3. 尾数溢出：当尾数最高有效位进位时，发生尾数溢出。此时进行右归操作：尾数右移一位，阶码加一，直到尾数不溢出为止。此时只要阶码不发生上溢出，浮点数就不会溢出磁道
   4. 非规格化尾数：当数值部分高位不是一个有效值时（如原码时为0或补码时与符号位相同），此时进行左规操作：尾数左移一位，阶码减一，知道尾数为规格化为止
   
7. 70-4：取 n = 8, 你的问题就变为 -128 的补码为什么 是 1000 0000忘掉&nbsp;所谓的补码计算公式吧 -> (正数不变，负数除符号位之外，其余各位取反，最后+1)补码的本质&nbsp;同余同余&nbsp;运算了解哇？&nbsp;1&nbsp;≡&nbsp;257&nbsp;(mod&nbsp;256)&nbsp; &nbsp;0&nbsp;≡&nbsp;256&nbsp;(mod&nbsp;256) -1&nbsp;≡&nbsp;255&nbsp;(mod&nbsp;256)&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;-1&nbsp;的补码是&nbsp;255:&nbsp;1111&nbsp;1111-2&nbsp;≡&nbsp;254&nbsp;(mod&nbsp;256)&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;-2&nbsp;的补码是&nbsp;254:&nbsp;1111&nbsp;1110所以&nbsp;-128 ≡ 128 (mod 256) -> -128 的补码是 128: 1000 0000说的远一点，数轴上任何一个整数都可以通过加减 256的整数倍 跳到0-255之间，它最后落到的位置就是它的补码比如计算机存储 -1， 实际就是存储的 255：1111 1111；注意基数只管阶码那一段，你要知道尾数依旧是二进制表示；

8. 70-8：左规右规的次数问题，两个n位数的加减运算，其和/差最多为n+1位，因此有可能需要右规，但右规最多一次。由于异号数相加或同号数相减。其和/差的最少位数无法确定，因此左规的次数也无法确定，但最多不会超过尾数的字长n位次。

9. 70-9： 原码表示的尾数判断浮点数是否规格化：第一个数值位是否为“1”,是,规格化；否,非规格化。补码表示的尾数判断浮点数是否规格化：符号位与第一个数值位是否相异,是,规格化；否,非规格化（-1/2除外）；默认舍入取0舍1 

10. 70-10：无符号数的 -1 可以表示为 111111 这种；机器数为32个1时，int型数解释时其值为-1；int型最大可表示的是0后面加31个1；IEEE 754用阶码全1、尾数全0表示无限大

### 三、算术逻辑单元（暂无）

### 四、存储系统

1. 91-2：分清楚磁带与磁盘的区别，顺序存取存储器（只能按某种顺序存取）与直接存取存储器（既不是顺序也不是随机，而是介于两者之中）都属于串行访问存储器
2. 92-5：相联存储器的基本原理是把存储单元所存内容的某一部分作为检索项去检索该存储器，并将存储器中与该检索项符合的存储单元内容进行读出或写入。所以他是按内容或地址寻址，价格比较昂贵，一般用来制作TLB。相联cache
3. 99-3：没有搞清楚地址线和数据线到底是干什么的，存储单元自然也不懂；地址线和存储单元个数相关；数据线和存储单元的字长相关；
4. 99-5：搞清楚什么是死时间；死时间是指刷新周期内利用一段固定的时间进行刷新操作，此时停止对存储器的读写操作；集中刷新必定有死时间，分散刷新把刷新操作分散到存取周期里面去不存在死时间，异步刷新只能减少死时间
5. 100-7：别人家说个半导体RAM你就不知道这是啥了啊……SRAM和DRAM都是这个大分类中的两个子类而已；易失性存储器是指断电后数据丢失，半导体RAM都是易失性存储器，只是DRAM需要刷新而已
6. 100-9：什么是地址复用技术呢？地址复用技术只适用于DRAM，不适用于SRAM，地址复用技术是为了减少地址线的数目，增大DRAM的集成度， 分两次送行列地址，因为半导体存储芯片的核心存储矩阵是采用行列地址交叉确定存储单元，所以既可以像SRAM那样一次同时取得行列地址，提高运行速度，也可以像DRAM那样分两次取得行列地址，减少地址线的数量。  **行列地址复用**：比如你的存储器容量是16bit，那么可以将这16个比特组织成一个4*4的矩阵，为了找到某个你想要找的bit，比如第1行第2列的那个bit。你先发送二进制的01，表示要找的数据在第1行；接着发送二进制的10，表示要找的数据在第2列。这样一来你就找到了第1行第2列的那个bit。可以发现只要两根地址线就能寻找16个bit了，但是要发送两次地址（一次行地址，一次列地址）‍**行列独立**：同样的16bit存储器，这16个bit不是组织成一个矩阵，而是一个数组，标号0~15，所以需要四根地址线来寻找，譬如要找第12个bit，你发送地址线信号1100就能找到。可以发现行列独立的地址线数量比行列地址复用要多，但是地址数据只要一次就能传输完成。
   DRAM一般使用行列地址复用技术，而SRAM一般使用行列独立技术。（ 如果采用地址复用技术，通过行通选和列通选分行列两次传送地址信号，故而地址线减半为8根，数据线不变，控制线变成1根行通选、1根列通选以及读写控制线（可用1根可用2根），片选线用行通选代替 ）
7. 100-12：这所谓的硬件常识我都不知道，我哭了；闪存依然是ROM的一种，写入时必须先擦除原有数据，写速度比读速度慢不少，采用随机访问方式
8. 100-14：这个命名真的很有迷惑性：随机存取与随机存取存储器（RAM）不一样，支持随机存取的存储器不一定是RAM
9. 101-17：总感觉怪怪的；在工作中存储器的内容不会发生变化，就算是刷新也只是把原存的东西重新写入而已；刷新这个过程，并不是把信息读入CPU，也不是从CPU向内存存入信息，只是把信息读出，通过一个刷新放大器后右重新放回存储单元，刷新放大器集成在RAM中
10. 107-9：我被绕进去了啊orz，这个地方是16位存储器啊，单位变了啊，单位他娘的不是（8位）B好不好
11. 108-11：这情况是地址总线超出了所需地址线条数的情况
12. 108-14：你要注意片选地址线和本身地址线逆推的习惯哦，线是加起来的
13. 108-16：综合了一些考察DRAM的地址复用技术和刷新按行刷新的性质
14. 109-1：地址寄存器（MAR）用来存放当前CPU访问的内存单元地址，或者存放CPU写入内存的内存单元地址。数据寄存器（MDR）用来存放由内存中独处的信息或写入内存的信息
15. 117-4：这道题的理解是从CPU角度出发的
16. 117-5*：这个总线传送周期啊，你别急，如果知道是几体，就能求出总线传送周期；另外，画图能够有效理解这个时间到底是个怎么回事；
17. 117-6：高位多体交叉存储器由于在单个存储器中的字是连续存放的，不能够保存的程序的局部性原理；但低位多体交叉存储器由于是交叉存放，能够很好的满足程序的局部性原理
18. 117-8：一个存取周期，只能从头开始算
19. 118-1：这道题目的第二小问补充了117-4的问题，你可以这样理解，0.1*10^-6s内，整个存储器可以提供32位二进制信息，但是每个存储体必须经过400ns才能向CPU提供32位二进制信息
20. 125-1：由于cache中存放的时主存中某一部分信息的副本，所以不能认为总容量是两个层次的简单相加
21. 125-3：主存与cache中的块，一一对应，懂我意思吧，这个单元呢对应的则是字节，因为说了按字节编址嘛，另外还有从0开始计数的坑点
22. 126-4：是除数作为组数，余数作为组数中偏置而已，和第125-3有异曲同工之妙，是对于从0开始计数的不熟悉感
23. 126-6：你要知道的是cache的更新策略都是发生在写操作中的，跟读操作可没什么关系
24. 126-8：记住地址的结构哦，需要算的，不要按答案那种算，影响理解
25. 127-13：这道题确实不错，考察主存块与cache块一一对应的关系，从而考察简单的替换原则，另外还考察C语言中的存取访存情况看你是否能分析清楚
26. 127-15：首先你需要搞清楚啥是指令cache和数据cache，通常情况下，L1 Cache会被划分成指令Cache和数据Cache，分别用于存储指令和数据，而L2 Cache、L3 Cahce等则是指令和数据混合存储。这实际上是因为目前的CPU架构基本上都是改进的哈佛架构。也就是说，指令和数据存储在不同的Cache中，使得CPU内核在执行时可以同时取指令和访问数据，提高效率；同时，由于指令通常情况下不会动态修改，而数据则需要频繁的修改，因此可以进一步优化指令Cache的设计，提高执行效率。只有在CPU无法从L1 Cache找到需要的指令或数据时（术语叫做“未命中”或者"Miss"）或者需要对修改过的数据进行同步时，才会进一步访问L2 Cache、L3 Cahce、SDRAM等。 指令流水线是为提高处理器执行指令的效率，把一条指令的操作分成多个细小的步骤，每个步骤由专门的电路完成的方式 
27. 139-3：段页式虽然是看起来段页都有，但是！！！它是把程序按逻辑结构分段，然后每段再划分成固定大小的页，主存空间也是划分为大小相等的页，所以程序对主存的调入调出操作，页还是基本的传送单位
28. 140-4：这道题可以让你搞清楚Cache、TLB、Page之间的关系；Cache中存放的是主存中的一部分副本，TLB存放的是Page的一部分副本。在同时具有虚拟页式存储器和Cache的系统中，CPU发出访存指令，先查找TLB和Page，再查找的是对应的Cache块。然后，分为两种情况：
    - 如果Cache命中了，说明所需内容在Cache中，那么所在页面必然以及调入内存中了，所以Page必定命中，但是TLB不一定能够命中哦
    - 如果Cache没命中，并不能说明所需内容未调入内存，和TLB、Page是否命中没有关系。但是如果TLB命中，那么Page必定命中；Page命中则不能说明TLB是否命中
29. 140-7：和操作系统前面的对应看看
30. 141-11：别把Cache和TLB搞混了，Cache命中后直接就在Cache中取了，不需要再访问主存；但全写法需要重新把数据写回Cache和主存中，所以需要访问一次主存

### 五、指令系统与中央处理器

1. 153-3：运算型指令寻址的是操作数，而转移型指令寻址的是程序转移地址

2. 153-8：指令的地址个数和指令的长度是否固定没有必然联系，即使是单地址指令也可能由于单地址的寻址方式不同而导致指令长度不同

3. 162-2：首先，我们采用不同寻址方式的原因是为了缩短指令字长，扩大寻址空间，提高编程灵活性；但是，由于不同的寻址方式多了，增大了我们的译码难度；最后，实现程序控制的是转移指令

4. 163-16：这个考察的只有进位标志和零标志，与符号标志、溢出标志无关

5. 164-17：这题我估计它在考什么你都没看懂，虽然选对了但根本没懂；发现自己连题目都没看懂，笑死

6. 164-20、21、22：操作数有效地址和操作数本身是不一样的，按照操作数地址取到的内容才是操作数本身

7. 164-24：这道题目的问题你没弄明白

8. 165-1：这个需要理解记忆：

   - 由于通用寄存器数量有限，可以用较少的二进制位来编码，所以采用寄存器寻址方式和寄存器间接寻址方式的指令码长度最短。因为需要在指令码中表示数据和地址，所以立即寻址方式、直接寻址方式和间接寻址方式指令码长度最长。如果指令码长度太短，则无法表示范围较大的立即数和寻址到较大的内存地址空间
   - 由于通用寄存器位于CPU内部，无需到内存中读取操作数，所以寄存器寻址方式执行速度最快。而间接寻址方式需要读内存两次，第一次由操作数的间接地址读到操作数的地址，第二次再由操作数的地址读到操作数，所以间接寻址方式执行速度最慢
   - 若指令系统采用定长指令码格式，所有指令所包含的二进制位数均相同，则立即寻址方式执行速度最快，因为读到指令的同时，便立即取得操作数。若采用变长指令码格式，由于表示一定范围内的立即数，包含立即数指令通常需要较多的二进制位，取指令时，可能需要不止一次读内存来完成取指令
   
9. 165-2：这道题目错在了PC那个地方，你需要知道的是变址寻址、基址寻址的优点是扩大寻址范围（寄存器位数大于形式地址A的位数），但是相对寻址就不一样了，PC的位数可并没有扩大寻址范围，所以按照形式地址的大小计算寻址范围

10. 166-5： ![](C:\Users\duzhaoteng\Pictures\8601a18b87d6277fdf45c09726381f30e824fcce.jpg)，另外，这道题第三小问用了助记符，记得仔细审题，明白它是什么意思

11. 167-7：这个补码呀，还是有符号位的，应该，至少现在写的题全部满足条件，另外你这个臭弟弟别老拿有效地址当内容好不好啊臭傻逼？？？

1. 182-184（概念实在了解的不清晰）：
   
   1. 运算器（接收从控制器送来的命令并执行相应的动作）：
      - 算术逻辑单元（ALU）
      - 暂存寄存器（暂存从主存读来的数据，数据不能存放在通用寄存器）（对应用程序员透明，透明即不可见）
      - 累加寄存器（ACC）
      - 通用寄存器（不透明）（可编程指定多种功能的寄存器）（不能替代指令寄存器）（位数由机器字长决定）
      - 程序状态字寄存器（又称为标志寄存器，是条件转移指令执行时所依据的条件来源）（PSW）（其中的位参与并决定微操作的形成）（不透明）
      - 移位器
      - 计数器（CT）
   2. 控制器（执行指令，每条指令的执行是由控制器发出的一组微操作实现的）：
      - 程序计数器（PC）（位数一般与MAR的位数一致）（位数由存储器的容量决定， PC取指令是一条一条取出来的，本来按字节编址确实是32位，但是这里条件说了，PC至少是多少位，那么已知道PC为32位一定是OK的，每次取指令的时候是4B，4GB/4B，就是1G的寻址范围，那么只需要30位即可，满足至少的条件）
      - 指令寄存器（IR）（透明的）（位数由指令字长决定）
      - 指令译码器（只对指令操作码字段进行译码，用来确定指令的操作功能）
      - 存储器地址寄存器（MAR）（透明的）（你要知道这玩意是用于存放所要访问的主存单元的地址，位数自然与主存有关）
      - 存储器数据寄存器（MDR）（透明的）（这个是用于存放向主存写入的信息或从主存中读出的信息，所以这个其实跟机器字长有关）
      - 时序系统
      - 微操作信号发生器（根据IR的内容指令、PSW的内容状态信息以及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构由组合逻辑型和存储逻辑型两种）
   
2. 184-23：其实考察的就是寄存器位的大小由什么决定，但考察的很灵活

3. 190-1：这我真不知道，考察的是指令和数据都在存储器中以二进制形式保存，那么如何区别呢？无它，就是CPU根据指令周期的不同阶段判断，当然，这种区分是在控制器的控制下进行的

4. 190-2：指令预取技术：如果不采取，那么每个指令周期都需要取指令；即使是空操作指令，在取指令操作后，PC也会自动加1；开中断状态：每条指令结束时都有可能被外部中断打断

5. 190-4：存取周期是指存储器进行两次独立的存储器操作的最小时间间隔

6. 190-6： CPU内部设有程序计数器PC，PC中的内容就是指令地址。程序的指令在PC中是顺序存放的。程序顺序执行时，PC的内容自动递增，形成下一条指令地址。当执行转移指令，改变程序执行顺序时，CPU将转移目的地址送给PC，形成了转移后的指令地址。也因此，指令总是根据程序计数器从主存中读出

7. 190-9：取指操作是自动进行的，控制器不需要得到相应的指令

8. 190-10：（操作码+地址码（指令地址））=（指令字）

9. 190-15：中断周期用于响应中断，若有中断，则在指令的执行周期后进入中断周期

10. 190-18：指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，那么需要两次访存，取指周期等于机器周期的2倍；如果指令字长等于机器字长，取值周期等于机器周期；指令字长和机器字长的长度没有任何关系

11. 196-3：记住就好，这个也不太好描述

23. 196-1：完整地分析一遍吧，很重要：

    | 时钟 | 功能                          | 描述                                                         | 有效控制信号         |
    | ---- | ----------------------------- | ------------------------------------------------------------ | -------------------- |
    | C1   | (PC) -> MAR                   | 在读写存储器前，必须先将地址送至MAR                          | PCout、MARin         |
    | C2   | M(MAR) -> MDR, (PC) + 1 -> PC | 读写的数据必须经过MDR，指令取出后PC自增1                     | MemR、MDRinE、PC + 1 |
    | C3   | M(MDR) -> IR                  | 将读到的MDR中的指令代码送至IR进行后续操作                    | MDRout、IRin         |
    | C4   | 指令译码                      |                                                              |                      |
    | C5   | (R1) -> MAR                   |                                                              | R1out、MARin         |
    | C6   | M(MAR) -> MDR                 |                                                              | MemR、MDRin          |
    | C7   | (MDR) -> A                    |                                                              | MDRout、Ain          |
    | C8   | (A) + (R0) -> AC              | 执行加法操作，将结果写回到R1内容所指的主存单元，注意MAR中的内容没有变 | R0out、Add、ACin     |
    | C9   | (AC) -> MDR                   |                                                              | ACout、MDRin         |
    | C10  | (MDR) -> M(MAR)               |                                                              | MDRoutE、MemR、MARin |

24. 215-218（又是一个不做题不好理解的题目）：

    1. 基本概念：
       - 每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令
       - 一个机器指令可以分解成一个微操作序列
       - 通常一条机器指令对应一个微程序
       - 微命令和微操作一一对应，微命令是微操作的控制信号，微操作是微命令的执行过程
       - 相容性微命令——同时产生、共同完成某一些微操作的微命令
       - 互斥性微命令——不允许同时出现的微命令
       - 微指令是若干微命令的集合
       - 存放微指令的控制存储器的单元地址称为微地址（操作控制字段、顺序控制字段）
       - 微周期指从控制存储器中读取一条微指令并执行相应的微操作所需时间
    2. 工作过程与组成
       - 工作过程：在微程序控制器的控制下计算机执行机器指令的过程
       - 由于任何一条机器指令的取指令操作都是相同的，因此可将取指令操作的微指令统一编成一个微程序，这个微程序只负责将指令从主存单元中取出并送至指令寄存器——控制存储器中的微程序个数应为机器指令数再加上对应取指、间址、中断周期等共用的微程序数
       - 详细过程：
         1. 执行取微指令公共操作：在机器开始运行时，自动将取指微程序的入口地址送入微地址寄存器，并从控制存储器中读出相应的微指令送入微指令寄存器（CMDR），当取指微程序执行完后，从主存中取出的机器指令就已存入指令寄存器中
         2. 由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入微程序地址寄存器
         3. 从控制存储器中逐条取出对应的微指令并执行
         4. 执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第1步，完成下一条机器指令的公共操作

25. 215-10：这个地方需要搞清楚到底什么是控制部件与执行部件，其实也没什么，只是控制存储器的两个部分，搞清楚分别是干什么的就行了

26. 215-12（注意微程序与微指令的对应关系）：

    | 微指令的格式（与微指令的编码方式有关） | 微程序长度 | 执行速度 | 微指令长度 | 编写微程序 |
    | :------------------------------------: | :--------: | :------: | :--------: | :--------: |
    |              水平型微指令              |     短     |    快    |     长     |    麻烦    |
    |              垂直型微指令              |     长     |    慢    |     短     |    简单    |

27. 216-14：这个考察微指令的编码方式，就考察的相当灵活了，注意字段直接编码方式中每个小段还要留出一个状态，表示本字段不发出任何微命令，通常用000表示

### 六、总线与输入输出系统

1. 246-1：取指令时，指令便是在数据线上传输的。操作数显然在数据线上传输。中断类型号用以指出中断向量的地址，CPU响应中断请求后，将中断应答信号发回数据总线，CPU从数据总线读取中断类型号后，查找中断向量表，找到相应的中断处理程序入口。而握手信号属于通信联络控制信号，应在控制总线上传输；

   - 数据总线用来传输个功能部件之间的数据信息，它是双向传输总线，其位数与机器字长、存储字长有关
   - 地址总线用来指出数据总线上的源数据或目的数据所在的主存单元或I/O端口的地址，它是单向传输总线，地址总线的位数与主存空间的大小有关
   - 控制总线传输的是控制信息，包括CPU送出的控制命令和主存返回CPU的反馈信号

2. 246-2：总线带宽是指单位时间内总线上传输数据的位数，通常用每秒传送信息的字节数来衡量。单位为B/s

3. 246-3：总线的猝发传输方式：在一个总线周期内传输存储地址连续的多个数据字的总线传输方式，称为猝发传送；关键这题重点不是这个什么猝发传送啊，考的是先送地址。。。先记住吧

4. 247-5：猝发传输：多个存储地址连续的数据；

   ​			 并行传输：在传输中有多个数据为同时在设备之间进行的传输

   ​             串行传输：数据的二进制代码在一条物理信道上以位为单位按时间顺序逐位传输的方式

   ​             同步传输：传输过程由统一的时钟控制

5. 



