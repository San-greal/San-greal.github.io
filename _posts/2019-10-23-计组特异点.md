---
layout:     post
title:      计组特异点
subtitle:   
date:       2019-10-23
author:     度朝腾
catalog: true
tags:
    - 计组
---

### 一、定点数的表示与运算

1. 47-2：这种题其实并不是考察定点数的乘法运算，在这种题使用乘法运算极度吃亏，相反，考察的是定点数的表示范围，通过转化成十进制，并搞清楚定点数表示的十进制范围，然后通过比较从而判断是否溢出。

2. 47-3：这题考察了大/小端地址以及数据边界对齐的问题，具体的可以查看178页的解释，注意这道题目中的字节分配，可以看答案明白

3. 48-10：这道题目考察的是对于 0 这个比较特殊的情况，原码、反码、补码和移码的区别，从而根据 0 所存在的形式数量，判断不同数据的存在数量：

   1. 原码[+0] = 00000 和 [-0] = 10000
   2. 补码[+0] = [-0] = 0.0000
   3. 反码[+0] = 0.0000 和 [-0] = 1.1111
   4. 移码[+0] = [-0] = 10000

4. 48-11：考察定点数范围以及你对它的熟练度，知道为什么，才能做，这个我建议去看

   [定点数表示范围分析]: https://www.jianshu.com/p/4bcf48987c1f

5. 49-20：这个描述把我坑了，补码与移码的 0 各自表示时当然唯一，但是它们之间相互比较自然不一样

6. 47-28：这道题比较特别，主要是B选项的问题，x 为正数只是充分条件，比如说 x = 0 就打破了这个当且仅当条件，另外需要注意的是，补码的表示形式全部唯一

7. 50-29：这他娘考的就是符号扩展

8. 50-32：你都不知道模4补码是啥？书上41面，双符号位也称模4补码，具体理解可以看

   [模4补码]: https://www.zybang.com/question/8aef3eaf78e5fa54c98c36fa43c63084.html

   要注意的是，存储模4补码只需要一个符号位，因为任何一个正确的数值，模4补码的两个符号位都是相同的

9. 50-35：注意题目的表述，默认认为描述 -0 这种就是原码和反码了

10. 51-42：考察溢出的判断条件，如果再次出错，建议重新观看42页

11. 51-45：描述很奇怪，之后可能还需要判断，这个描述看来，它给你的是什么，本身的机器码就是什么，而且本身还考察了溢出的判断问题

12. 52-54：在计算机中，主存地址主要都是用无符号数表示，因为主存地址都是正数所以不需要符号位

13. 52-58：这他娘考的就是符号扩展，别想多了

14. 52-59：搞清楚逻辑移位与算术移位的区别

15. 53-2：你需要知道的是，这些转换来转换去，机器码本身是不变的，变化的只是对机器码的解释

16. 54-6：变形补码又称之为双符号位，也叫模4补码

### 二、浮点数的表示与运算

1. 66-6：错的知识点都差不多，需要知道的是，阶码位数越多表示的数范围越大，尾数位数越多表示的精度越高

2. 66-7： ![img](https://gss0.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=c43f37c163224f4a57cc7b1539c7bc6a/024f78f0f736afc30ff57e82bd19ebc4b645125f.jpg) 

   ​		这道题就是没搞清楚基数是啥，基数就是这里面的2咯，一般来说是默认为2，当然，可能改成别的考，另外

   存在几个还没搞清楚咋回事的东西：

   - 基数越大，在运算中尾数右移的可能性越小，运算的精度损失越小
   - 基数大时发生因对阶或尾数溢出需右移及规格化需左移的次数显著减少，运算速度可以提高
   - 基数越大，可以表示的数越多
   - 基数越大，范围越大，但精度变小（数变稀疏，因为乘的时候范围变大了，所以变稀疏了（离散了））

3. 67-10：注意，IEEE 754的规则是隐藏了那一个1，但是你自己的规定没说隐藏，所以你懂的

4. 67-11：没有搞清楚为什么要进行浮点数规格化，其实是为了提高精度的同时，保证数据的唯一性， 在计算机内，对非0值的浮点数，要求尾数的绝对值必须大于基数的倒数（默认小于等于1），这就要求尾数的最高有效位是1，满足这种表示要求的浮点数称为规格化表示，不满足条件的就需要规格化咯。 **按规格化的定义-1/2确实应该是算规格化数，但是在机器实际判断规格化与否（以补码为例）是根据符号位与有效位最高位是否不同老判断的，即认为符号位与有效位最高位不同时才是规格化数，所以-1/2又不算规格化数，而根据定义-1本来不算规格化数，但其补码表示为11.0000，机器识别其是规格化数，所以应该是要站在机器判断的角度看，这两个是特殊情况**，另外这道题a选项有个小问题，就是它现在是补码，你必须先把它化成原码再取绝对值 

5. 67-14：注意国际标准中的尾数编码是原码！

6. 68-29、30、31：定点数是没有舍入概念的，别瞎搞；浮点数舍入有两种情况，对阶和右规格化；舍入不一定产生误差，比如说11.00 -> 11.0就没有产生误差；想要具体搞清楚这几道题，我们需要知道什么是溢出：

   1. 阶码上溢：一个正指数超过了最大允许值时，浮点数发生上溢，若结果是正数，发生正上溢出，若结果是负数，发生负上溢出。这种情况为软件故障，通常要引入溢出故障处理程序处理
   2. 阶码下溢：一个负指数比最小允许值还小时，浮点数发生下溢出。一般机器把下溢出时的值置为0，不发生溢出故障
   3. 尾数溢出：当尾数最高有效位进位时，发生尾数溢出。此时进行右归操作：尾数右移一位，阶码加一，直到尾数不溢出为止。此时只要阶码不发生上溢出，浮点数就不会溢出磁道
   4. 非规格化尾数：当数值部分高位不是一个有效值时（如原码时为0或补码时与符号位相同），此时进行左规操作：尾数左移一位，阶码减一，知道尾数为规格化为止
   
7. 70-4：取 n = 8, 你的问题就变为 -128 的补码为什么 是 1000 0000忘掉&nbsp;所谓的补码计算公式吧 -> (正数不变，负数除符号位之外，其余各位取反，最后+1)补码的本质&nbsp;同余同余&nbsp;运算了解哇？&nbsp;1&nbsp;≡&nbsp;257&nbsp;(mod&nbsp;256)&nbsp; &nbsp;0&nbsp;≡&nbsp;256&nbsp;(mod&nbsp;256) -1&nbsp;≡&nbsp;255&nbsp;(mod&nbsp;256)&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;-1&nbsp;的补码是&nbsp;255:&nbsp;1111&nbsp;1111-2&nbsp;≡&nbsp;254&nbsp;(mod&nbsp;256)&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;-2&nbsp;的补码是&nbsp;254:&nbsp;1111&nbsp;1110所以&nbsp;-128 ≡ 128 (mod 256) -> -128 的补码是 128: 1000 0000说的远一点，数轴上任何一个整数都可以通过加减 256的整数倍 跳到0-255之间，它最后落到的位置就是它的补码比如计算机存储 -1， 实际就是存储的 255：1111 1111；注意基数只管阶码那一段，你要知道尾数依旧是二进制表示；

8. 70-8：左规右规的次数问题，两个n位数的加减运算，其和/差最多为n+1位，因此有可能需要右规，但右规最多一次。由于异号数相加或同号数相减。其和/差的最少位数无法确定，因此左规的次数也无法确定，但最多不会超过尾数的字长n位次。

9. 70-9： 原码表示的尾数判断浮点数是否规格化：第一个数值位是否为“1”,是,规格化；否,非规格化。补码表示的尾数判断浮点数是否规格化：符号位与第一个数值位是否相异,是,规格化；否,非规格化（-1/2除外）；默认舍入取0舍1 

10. 70-10：无符号数的 -1 可以表示为 111111 这种；机器数为32个1时，int型数解释时其值为-1；int型最大可表示的是0后面加31个1；IEEE 754用阶码全1、尾数全0表示无限大

### 三、算术逻辑单元（暂无）

### 四、存储系统

1. 91-2：分清楚磁带与磁盘的区别，顺序存取存储器（只能按某种顺序存取）与直接存取存储器（既不是顺序也不是随机，而是介于两者之中）都属于串行访问存储器
2. 92-5：相联存储器的基本原理是把存储单元所存内容的某一部分作为检索项去检索该存储器，并将存储器中与该检索项符合的存储单元内容进行读出或写入。所以他是按内容或地址寻址，价格比较昂贵，一般用来制作TLB。相联cache
3. 99-3：没有搞清楚地址线和数据线到底是干什么的，存储单元自然也不懂；地址线和存储单元个数相关；数据线和存储单元的字长相关；
4. 99-5：搞清楚什么是死时间；死时间是指刷新周期内利用一段固定的时间进行刷新操作，此时停止对存储器的读写操作；集中刷新必定有死时间，分散刷新把刷新操作分散到存取周期里面去不存在死时间，异步刷新只能减少死时间
5. 100-7：别人家说个半导体RAM你就不知道这是啥了啊……SRAM和DRAM都是这个大分类中的两个子类而已；易失性存储器是指断电后数据丢失，半导体RAM都是易失性存储器，只是DRAM需要刷新而已
6. 100-9：什么是地址复用技术呢？地址复用技术只适用于DRAM，不适用于SRAM，地址复用技术是为了减少地址线的数目，增大DRAM的集成度， 分两次送行列地址，因为半导体存储芯片的核心存储矩阵是采用行列地址交叉确定存储单元，所以既可以像SRAM那样一次同时取得行列地址，提高运行速度，也可以像DRAM那样分两次取得行列地址，减少地址线的数量。  **行列地址复用**：比如你的存储器容量是16bit，那么可以将这16个比特组织成一个4*4的矩阵，为了找到某个你想要找的bit，比如第1行第2列的那个bit。你先发送二进制的01，表示要找的数据在第1行；接着发送二进制的10，表示要找的数据在第2列。这样一来你就找到了第1行第2列的那个bit。可以发现只要两根地址线就能寻找16个bit了，但是要发送两次地址（一次行地址，一次列地址）‍**行列独立**：同样的16bit存储器，这16个bit不是组织成一个矩阵，而是一个数组，标号0~15，所以需要四根地址线来寻找，譬如要找第12个bit，你发送地址线信号1100就能找到。可以发现行列独立的地址线数量比行列地址复用要多，但是地址数据只要一次就能传输完成。
   DRAM一般使用行列地址复用技术，而SRAM一般使用行列独立技术。（ 如果采用地址复用技术，通过行通选和列通选分行列两次传送地址信号，故而地址线减半为8根，数据线不变，控制线变成1根行通选、1根列通选以及读写控制线（可用1根可用2根），片选线用行通选代替 ）
7. 100-12：这所谓的硬件常识我都不知道，我哭了；闪存依然是ROM的一种，写入时必须先擦除原有数据，写速度比读速度慢不少，采用随机访问方式
8. 100-14：这个命名真的很有迷惑性：随机存取与随机存取存储器（RAM）不一样，支持随机存取的存储器不一定是RAM
9. 101-17：总感觉怪怪的；在工作中存储器的内容不会发生变化，就算是刷新也只是把原存的东西重新写入而已；刷新这个过程，并不是把信息读入CPU，也不是从CPU向内存存入信息，只是把信息读出，通过一个刷新放大器后右重新放回存储单元，刷新放大器集成在RAM中
10. 107-9：我被绕进去了啊orz，这个地方是16位存储器啊，单位变了啊，单位他娘的不是（8位）B好不好
11. 108-11：这情况是地址总线超出了所需地址线条数的情况
12. 108-14：你要注意片选地址线和本身地址线逆推的习惯哦，线是加起来的
13. 108-16：综合了一些考察DRAM的地址复用技术和刷新按行刷新的性质
14. 109-1：地址寄存器（MAR）用来存放当前CPU访问的内存单元地址，或者存放CPU写入内存的内存单元地址。数据寄存器（MDR）用来存放由内存中独处的信息或写入内存的信息
15. 117-4：这道题的理解是从CPU角度出发的
16. 117-5*：这个总线传送周期啊，你别急，如果知道是几体，就能求出总线传送周期；另外，画图能够有效理解这个时间到底是个怎么回事；
17. 117-6：高位多体交叉存储器由于在单个存储器中的字是连续存放的，不能够保存的程序的局部性原理；但低位多体交叉存储器由于是交叉存放，能够很好的满足程序的局部性原理
18. 117-8：一个存取周期，只能从头开始算
19. 118-1：这道题目的第二小问补充了117-4的问题，你可以这样理解，0.1*10^-6s内，整个存储器可以提供32位二进制信息，但是每个存储体必须经过400ns才能向CPU提供32位二进制信息
20. 125-1：由于cache中存放的时主存中某一部分信息的副本，所以不能认为总容量是两个层次的简单相加
21. 126-3：主存与cache中的块，一一对应，懂我意思吧，这个单元呢对应的则是字节，因为说了按字节编址嘛，另外还有从0开始计数的坑点
22. 126-4：是除数作为组数，余数作为组数中偏置而已，和第125-3有异曲同工之妙，是对于从0开始计数的不熟悉感
23. 126-6：你要知道的是cache的更新策略都是发生在写操作中的，跟读操作可没什么关系
24. 126-8：记住地址的结构哦，需要算的，不要按答案那种算，影响理解
25. 127-13：这道题确实不错，考察主存块与cache块一一对应的关系，从而考察简单的替换原则，另外还考察C语言中的存取访存情况看你是否能分析清楚
26. 127-15：首先你需要搞清楚啥是指令cache和数据cache，通常情况下，L1 Cache会被划分成指令Cache和数据Cache，分别用于存储指令和数据，而L2 Cache、L3 Cahce等则是指令和数据混合存储。这实际上是因为目前的CPU架构基本上都是改进的哈佛架构。也就是说，指令和数据存储在不同的Cache中，使得CPU内核在执行时可以同时取指令和访问数据，提高效率；同时，由于指令通常情况下不会动态修改，而数据则需要频繁的修改，因此可以进一步优化指令Cache的设计，提高执行效率。只有在CPU无法从L1 Cache找到需要的指令或数据时（术语叫做“未命中”或者"Miss"）或者需要对修改过的数据进行同步时，才会进一步访问L2 Cache、L3 Cahce、SDRAM等。 指令流水线是为提高处理器执行指令的效率，把一条指令的操作分成多个细小的步骤，每个步骤由专门的电路完成的方式 
27. 139-3：段页式虽然是看起来段页都有，但是！！！它是把程序按逻辑结构分段，然后每段再划分成固定大小的页，主存空间也是划分为大小相等的页，所以程序对主存的调入调出操作，页还是基本的传送单位
28. 140-4：这道题可以让你搞清楚Cache、TLB、Page之间的关系；Cache中存放的是主存中的一部分副本，TLB存放的是Page的一部分副本。在同时具有虚拟页式存储器和Cache的系统中，CPU发出访存指令，先查找TLB和Page，再查找的是对应的Cache块。然后，分为两种情况：
    - 如果Cache命中了，说明所需内容在Cache中，那么所在页面必然以及调入内存中了，所以Page必定命中，但是TLB不一定能够命中哦
    - 如果Cache没命中，并不能说明所需内容未调入内存，和TLB、Page是否命中没有关系。但是如果TLB命中，那么Page必定命中；Page命中则不能说明TLB是否命中
29. 140-7：和操作系统前面的对应看看
30. 141-11：别把Cache和TLB搞混了，Cache命中后直接就在Cache中取了，不需要再访问主存；但全写法需要重新把数据写回Cache和主存中，所以需要访问一次主存

### 五、指令系统与中央处理器

1. 153-3：运算型指令寻址的是操作数，而转移型指令寻址的是程序转移地址

2. 153-8：指令的地址个数和指令的长度是否固定没有必然联系，即使是单地址指令也可能由于单地址的寻址方式不同而导致指令长度不同

3. 162-2：首先，我们采用不同寻址方式的原因是为了缩短指令字长，扩大寻址空间，提高编程灵活性；但是，由于不同的寻址方式多了，增大了我们的译码难度；最后，实现程序控制的是转移指令

4. 163-16：这个考察的只有进位标志和零标志，与符号标志、溢出标志无关

5. 164-17：这题我估计它在考什么你都没看懂，虽然选对了但根本没懂；发现自己连题目都没看懂，笑死

6. 164-20、21、22：操作数有效地址和操作数本身是不一样的，按照操作数地址取到的内容才是操作数本身

7. 164-24：这道题目的问题你没弄明白

8. 165-1：这个需要理解记忆：

   - 由于通用寄存器数量有限，可以用较少的二进制位来编码，所以采用寄存器寻址方式和寄存器间接寻址方式的指令码长度最短。因为需要在指令码中表示数据和地址，所以立即寻址方式、直接寻址方式和间接寻址方式指令码长度最长。如果指令码长度太短，则无法表示范围较大的立即数和寻址到较大的内存地址空间
   - 由于通用寄存器位于CPU内部，无需到内存中读取操作数，所以寄存器寻址方式执行速度最快。而间接寻址方式需要读内存两次，第一次由操作数的间接地址读到操作数的地址，第二次再由操作数的地址读到操作数，所以间接寻址方式执行速度最慢
   - 若指令系统采用定长指令码格式，所有指令所包含的二进制位数均相同，则立即寻址方式执行速度最快，因为读到指令的同时，便立即取得操作数。若采用变长指令码格式，由于表示一定范围内的立即数，包含立即数指令通常需要较多的二进制位，取指令时，可能需要不止一次读内存来完成取指令
   
9. 165-2：这道题目错在了PC那个地方，你需要知道的是变址寻址、基址寻址的优点是扩大寻址范围（寄存器位数大于形式地址A的位数），但是相对寻址就不一样了，PC的位数可并没有扩大寻址范围，所以按照形式地址的大小计算寻址范围

10. 166-5： ![](C:\Users\duzhaoteng\Pictures\8601a18b87d6277fdf45c09726381f30e824fcce.jpg)，另外，这道题第三小问用了助记符，记得仔细审题，明白它是什么意思

11. 167-7：这个补码呀，还是有符号位的，应该，至少现在写的题全部满足条件，另外你这个臭弟弟别老拿有效地址当内容好不好啊臭傻逼？？？

1. 182-184（概念实在了解的不清晰）：
   
   1. 运算器（接收从控制器送来的命令并执行相应的动作）：
      - 算术逻辑单元（ALU）
      - 暂存寄存器（暂存从主存读来的数据，数据不能存放在通用寄存器）（对应用程序员透明，透明即不可见）
      - 累加寄存器（ACC）
      - 通用寄存器（不透明）（可编程指定多种功能的寄存器）（不能替代指令寄存器）（位数由机器字长决定）
      - 程序状态字寄存器（又称为标志寄存器，是条件转移指令执行时所依据的条件来源）（PSW）（其中的位参与并决定微操作的形成）（不透明）
      - 移位器
      - 计数器（CT）
   2. 控制器（执行指令，每条指令的执行是由控制器发出的一组微操作实现的）：
      - 程序计数器（PC）（位数一般与MAR的位数一致）（位数由存储器的容量决定， PC取指令是一条一条取出来的，本来按字节编址确实是32位，但是这里条件说了，PC至少是多少位，那么已知道PC为32位一定是OK的，每次取指令的时候是4B，4GB/4B，就是1G的寻址范围，那么只需要30位即可，满足至少的条件）
      - 指令寄存器（IR）（透明的）（位数由指令字长决定）
      - 指令译码器（只对指令操作码字段进行译码，用来确定指令的操作功能）
      - 存储器地址寄存器（MAR）（透明的）（你要知道这玩意是用于存放所要访问的主存单元的地址，位数自然与主存有关）
      - 存储器数据寄存器（MDR）（透明的）（这个是用于存放向主存写入的信息或从主存中读出的信息，所以这个其实跟机器字长有关）
      - 时序系统
      - 微操作信号发生器（根据IR的内容指令、PSW的内容状态信息以及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构由组合逻辑型和存储逻辑型两种）
   
2. 184-23：其实考察的就是寄存器位的大小由什么决定，但考察的很灵活

3. 190-1：这我真不知道，考察的是指令和数据都在存储器中以二进制形式保存，那么如何区别呢？无它，就是CPU根据指令周期的不同阶段判断，当然，这种区分是在控制器的控制下进行的

4. 190-2：指令预取技术：如果不采取，那么每个指令周期都需要取指令；即使是空操作指令，在取指令操作后，PC也会自动加1；开中断状态：每条指令结束时都有可能被外部中断打断

5. 190-4：存取周期是指存储器进行两次独立的存储器操作的最小时间间隔

6. 190-6： CPU内部设有程序计数器PC，PC中的内容就是指令地址。程序的指令在PC中是顺序存放的。程序顺序执行时，PC的内容自动递增，形成下一条指令地址。当执行转移指令，改变程序执行顺序时，CPU将转移目的地址送给PC，形成了转移后的指令地址。也因此，指令总是根据程序计数器从主存中读出

7. 190-9：取指操作是自动进行的，控制器不需要得到相应的指令

8. 190-10：（操作码+地址码（指令地址））=（指令字）

9. 190-15：中断周期用于响应中断，若有中断，则在指令的执行周期后进入中断周期

10. 190-18：指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，那么需要两次访存，取指周期等于机器周期的2倍；如果指令字长等于机器字长，取值周期等于机器周期；指令字长和机器字长的长度没有任何关系

11. 196-3：记住就好，这个也不太好描述

23. 196-1：完整地分析一遍吧，很重要：

    | 时钟 | 功能                          | 描述                                                         | 有效控制信号         |
    | ---- | ----------------------------- | ------------------------------------------------------------ | -------------------- |
    | C1   | (PC) -> MAR                   | 在读写存储器前，必须先将地址送至MAR                          | PCout、MARin         |
    | C2   | M(MAR) -> MDR, (PC) + 1 -> PC | 读写的数据必须经过MDR，指令取出后PC自增1                     | MemR、MDRinE、PC + 1 |
    | C3   | M(MDR) -> IR                  | 将读到的MDR中的指令代码送至IR进行后续操作                    | MDRout、IRin         |
    | C4   | 指令译码                      |                                                              |                      |
    | C5   | (R1) -> MAR                   |                                                              | R1out、MARin         |
    | C6   | M(MAR) -> MDR                 |                                                              | MemR、MDRin          |
    | C7   | (MDR) -> A                    |                                                              | MDRout、Ain          |
    | C8   | (A) + (R0) -> AC              | 执行加法操作，将结果写回到R1内容所指的主存单元，注意MAR中的内容没有变 | R0out、Add、ACin     |
    | C9   | (AC) -> MDR                   |                                                              | ACout、MDRin         |
    | C10  | (MDR) -> M(MAR)               |                                                              | MDRoutE、MemR、MARin |

24. 215-218（又是一个不做题不好理解的题目）：

    1. 基本概念：
       - 每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令
       - 一个机器指令可以分解成一个微操作序列
       - 通常一条机器指令对应一个微程序
       - 微命令和微操作一一对应，微命令是微操作的控制信号，微操作是微命令的执行过程
       - 相容性微命令——同时产生、共同完成某一些微操作的微命令
       - 互斥性微命令——不允许同时出现的微命令
       - 微指令是若干微命令的集合
       - 存放微指令的控制存储器的单元地址称为微地址（操作控制字段、顺序控制字段）
       - 微周期指从控制存储器中读取一条微指令并执行相应的微操作所需时间
    2. 工作过程与组成
       - 工作过程：在微程序控制器的控制下计算机执行机器指令的过程
       - 由于任何一条机器指令的取指令操作都是相同的，因此可将取指令操作的微指令统一编成一个微程序，这个微程序只负责将指令从主存单元中取出并送至指令寄存器——控制存储器中的微程序个数应为机器指令数再加上对应取指、间址、中断周期等共用的微程序数
       - 详细过程：
         1. 执行取微指令公共操作：在机器开始运行时，自动将取指微程序的入口地址送入微地址寄存器，并从控制存储器中读出相应的微指令送入微指令寄存器（CMDR），当取指微程序执行完后，从主存中取出的机器指令就已存入指令寄存器中
         2. 由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入微程序地址寄存器
         3. 从控制存储器中逐条取出对应的微指令并执行
         4. 执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第1步，完成下一条机器指令的公共操作

25. 215-10：这个地方需要搞清楚到底什么是控制部件与执行部件，其实也没什么，只是控制存储器的两个部分，搞清楚分别是干什么的就行了

26. 215-12（注意微程序与微指令的对应关系）：

    | 微指令的格式（与微指令的编码方式有关） | 微程序长度 | 执行速度 | 微指令长度 | 编写微程序 |
    | :------------------------------------: | :--------: | :------: | :--------: | :--------: |
    |              水平型微指令              |     短     |    快    |     长     |    麻烦    |
    |              垂直型微指令              |     长     |    慢    |     短     |    简单    |

27. 216-14：这个考察微指令的编码方式，就考察的相当灵活了，注意字段直接编码方式中每个小段还要留出一个状态，表示本字段不发出任何微命令，通常用000表示

### 六、总线

1. 246-1：取指令时，指令便是在数据线上传输的。操作数显然在数据线上传输。中断类型号用以指出中断向量的地址，CPU响应中断请求后，将中断应答信号发回数据总线，CPU从数据总线读取中断类型号后，查找中断向量表，找到相应的中断处理程序入口。而握手信号属于通信联络控制信号，应在控制总线上传输；

   - 数据总线用来传输个功能部件之间的数据信息，它是双向传输总线，其位数与机器字长、存储字长有关
   - 地址总线用来指出数据总线上的源数据或目的数据所在的主存单元或I/O端口的地址，它是单向传输总线，地址总线的位数与主存空间的大小有关
   - 控制总线传输的是控制信息，包括CPU送出的控制命令和主存返回CPU的反馈信号

2. 246-2：总线带宽是指单位时间内总线上传输数据的位数，通常用每秒传送信息的字节数来衡量。单位为B/s

3. 246-3：总线的猝发传输方式：在一个总线周期内传输存储地址连续的多个数据字的总线传输方式，称为猝发传送；关键这题重点不是这个什么猝发传送啊，**考的是先传送地址**。。。先记住吧

4. 247-5：猝发传输：一次总线事务中，主设备只需要给出一个首地址，从设备就能从首地址开始的若干连续单元读出或写入多个数据。多个存储地址连续的数据；

   ​			 并行传输：指每个数据位有一条单独的传输线，所有的数据位同时进行

   ​             串行传输：数据的二进制代码在一条物理信道上以位为单位按时间顺序逐位传输的方式

   ​             同步传输：传输过程由统一的时钟控制

5. 247-10：间址寻址首次访问内存所得到的信息是操作数的有效地址，该地址通过数据总线而非地址总线传送至CPU。地址总线是用于CPU选择主存单元地址和I/O端口地址的**单向总线**，不能回传；

6. 247-13：单周期处理器就是指所有指令的指令周期为一个时钟周期的处理器，CPI代表每条指令执行所需的时钟周期数；因为每条指令的CPI为1，要考虑较慢的指令，所以处理器的时钟周期较低；单周期处理器并不指采用单总线结构数据通路；控制信号即指PC中的内容，PC用来存放当前欲执行指令的地址，可以自动+1形成下一条指令的地址。所以指令执行过程中，控制信号不变化；

7. 247-15：不同信号在同一条信号线上分时传输的方式，称为总线复用方式

8. 248-18：应该在输入输出设备那一章会详细讲解这种题型

9. 248-22：

10. 248-23：在实际时钟频率较低的情况下，并行总线因为可以同时传输若干比特，速率确实比串行总线快？但是随着技术的发展，时钟频率越来越高，并行导线之间相互干扰越来越严重，当时钟频率提高到一定程度时，传输的数据已经无法恢复；而串行总线因为导线少，线间干扰容易控制，反而不断提高时钟频率来提高传输速率；总线复用是指一种信号线在不同的时间传输不同的信息，它可以使用较少的线路传输更多的信息，节省空间和成本；分离事务通信是总线复用的一种，相比单一的传输线路可以提高总线的利用率；

11. 248-24：多总线结构用速率高的总线连接高速设备，用速率低的总线连接低速设备；PCI-Express总线都采用串行数据包传输数据？？？

12. 254-1：这个是书上的原话，计数可以从0开始，此时一旦设备的优先次序被固定，设备的优先级就按0、1、...、n的顺序降序排列，而且固定不变；计数也可以从上一次的终点开始，即采用一种循环方法，此时设备使用总线的优先级相等；计数器的初值还可由程序设置，故优先次序可以改变，且这种方式对电路的故障没有链式查询敏感；

13. 254-2：在总线控制中，申请使用总线的设备向总线控制器发出总线请求，由总线控制器进行裁决。若经过裁决允许该设备使用总线，就由总线控制器向该设备发出总线允许信号，该设备收到信号后发出总线忙信号，通知其他设备总线已经被占用。该设备使用完总线后，将总线忙信号撤销，释放总线；

14. 254-6：独立请求方式的优先次序是可以通过程序改变的，控制非常灵活，所有肯定可以采用某种算法实现各个设备使用总线的机会相同。

15. 257-6：异步总线即采用异步通信方式的总线。在异步方式下，没有公用的时钟，完全依靠传送双方相互制约的握手信号来实现定时控制。传送操作时由双方按需分配时间的；所以这题别想多了；

16. 258-1：考察地叫做有效数据传输率

### 七、输入输出系统

1. 264-1：I/O设备不可能直接与主板总线相连，它总是通过设备控制器来相连。

2. 265-2：I/O指令是指令系统的一部分，是机器指令的一类，但其为了反映与I/O设备交互的特点，格式与其它通用指令有所不同

3. 265-3：通道程序存放在主存而非通道中，由通道从主存中取出并执行。通道程序由通道执行，且只能在具有通道的I/O系统中执行

4. 269-1：打印机从打字原理的角度来分，可分为击打式和非击打式两种，按照能否打出汉字来分，可分为点阵式打印机和活字式打印机；**键盘、数据等输入设备一般都采用中断方式来实现，原因在于CPU需要及时响应这些操作，否则容易造成输入的丢失；**

5. 269-2、3、4：计算机中一个汉字内码在主存中占用2B，输出的字型码 16 * 16 点阵在缓冲存储区占用 16 * 16/8 = 32B；在字符显示器的VRAM中存放ASCII码用以显示字符；每个汉字用16 * 16点阵标识

6. 270-8、11：这个还是操作系统讲的详细很多；对了，有个地方你理解错了，磁盘那玩意不是有转速嘛，转一圈假如为T，但是我们的时延是寻找扇区产生的，而找到这个扇区是平均时间，即T/2；

7. 274-1：I/O总线是在内存和外设之间传输数据的总线，根据信号线上传输信息内容的不同可分为三类：数据线、控制线和地址线。控制线和地址线都是单向传输的，从CPU传送给I/O接口，而I/O接口中的命令字，状态字及中断类型号均是由I/O接口发往CPU的，故只能通过I/O总线的数据线传输；

8. 275-9：物理地址是外部连接使用的，且是唯一的，它与地址总线相对应；而逻辑地址是内部和编程使用的，并不唯一。在内存中的实际地址就是所谓的物理地址，而逻辑地址就是用于逻辑段管理内存的，**因此程序员使用逻辑地址访问设备**

9. 275-11：在执行一条指令时，CPU使用地址总线选择所请求的I/O接口，使用数据总线在CPU寄存器和端口之间传输数据；

10. 284-1：浮点数运算下溢将按机器零处理，不会产生中断！！！！

11. 284-2：
    1. 中断隐指令（硬件）
       1. 关中断：CPU不应响应更高级中断源的中断请求
       2. 保存断点：断点可以压入堆栈，也可以存入主存的特定单元中
       3. 引出中断服务程序：取出中断服务程序的入口地址送入PC
          1. 硬件向量法：通过硬件产生中断向量地址，再由中断向量地址找到中断向量，中断向量就是中断服务程序的入口地址；实际上硬件产生的是中断类型号，而中断类型号指出了中断向量存放的地址；
          2. 软件查询法：用软件编程的方法寻找入口地址
    2. 中断服务程序（软件）
       1. 保护现场和屏蔽字：现场信息一般是指程序状态字、中断屏蔽寄存器和CPU中某些寄存器的内容
       2. 开中断：实现中断嵌套
       3. 执行中断服务程序：中断系统的核心
       4. 关中断：保证在恢复现场和屏蔽字时不被中断
       5. 恢复现场和屏蔽字
       6. 开中断、中断返回：**中断服务程序的最后一条指令通常是一条中断返回指令**，使其返回到原程序的断点，以便继续执行原程序；
    
12. 285-7：当有多个中断请求同时出现时，中断服务系统必须能从中选出当前最需要给予响应的且最重要的中断请求，这就需要预先对所有的中断进行优先级排队，这个工作可由中断判优逻辑来完成，排队的规则可由软件对中断屏蔽寄存器进行设置来确定（但是中断判优操作既可以由软件实现也可以由硬件实现）

13. 285-9：中断服务程序是处理器处理的紧急事件，可理解为一种服务，是通过执行事先编好的某个特定程序完成的，一般属于操作系统的模块，以供调用执行；

14. 285-12：DMA方式不需要CPU干预传送操作，仅在开始和结尾借用CPU一点时间，其余不占用CPU任何资源；中断方式是程序切换，每次操作需要保护和恢复现场，所以DMA优先级高于中断请求，从而可以加快执行效率；DMA的传送过程：
    1. 预处理：由CPU完成一些必要的准备工作。首先，CPU执行几条IO指令，用以测试IO设备状态，由DMA控制器的有关寄存器置初值、设置传送方向、启动该设备等。然后，CPU继续原来的程序，直到IO设备准备好发送的数据或接收的数据，IO设备想DMA控制器发送DMA请求，再由DMA控制器向CPU发送总线请求，用以传输数据；
    2. 数据传送：DMA数据传输可以以单字节或字为基本单位，也可以以数据块为基本单位。对于以数据块为单位的传送，DMA占用总线后的数据输入和输出操作都是通过循环来实现的。需要指出的是，这一循环也是由DMA控制器实现的，**数据传送阶段完全由DMA控制**
    3. 后处理：**DMA向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理**，包括校验送入主存的数据是否正确、测试传送过程中是否出错（错误则转入诊断程序）及决定是否继续用DMA传送其他数据块。
    
15. 286-13：IO设备的就绪时间是随机的，而CPU在统一的时刻即每条指令执行阶段**结束前**接口发出中断查询信号，以获取IO的中断请求，也就是说，CPU响应中断的时间是在每条指令执行阶段的**结束时刻**。CPU会在每个**存储周期结束后**检查是否有DMA请求，而不是每条指令的执行过程中；

16. 286-14：能产生DMA请求的总线部件只有具有DMA接口的设备

17. 286-15：

    1. 外中断
       1. 外设请求
       2. 人为干预
    2. 内中断
       1. 自愿中断：指令中断
       2. 强迫中断
          1. 硬件故障
          2. 软件中断

18. 286-18：一条指令执行完毕可能响应中断请求，但它本身不会引起中断请求

19. 286-19：主存故障引起的中断时机器校验中断，属于内中断，外中断一般指主存和CPU外的中断

20. 286-20：有点意思，这里用户程序需要输入/输出时，并不是说外设发起中断，这里是用户程序请求系统调用服务，所以是访管指令；

21. 286-24：中断触发器置0代表关中断

22. 286-27：有一说一，这个只能留些印象，中断请求一般来自CPU以外的事件，异常一般发生在CPU内部；

23. 286-29：

    | 输入/输出方式 | CPU与外设                                     | 传送与主程序                   |
    | ------------- | --------------------------------------------- | ------------------------------ |
    | 程序查询      | 串行（CPU不断查询外设状态，直到外设准备就绪） | 串行（中断主程序执行数据传送） |
    | 中断          | 并行                                          | 串行（中断主程序执行数据传送） |
    | DMA           | 并行                                          | 并行                           |

24. 286-33：每个机器周期结束后，CPU就可以响应DMA请求；DMA再主存交换数据时通过周期窃取方式，窃取的时存取周期；

25. 286-41：在程序中断输入输出方式中，CPU和打印机直接交换，打印字符直接传输到打印机的输入输出端口，不会涉及主存地址。而CPU和打印机通过输入输出端口中的状态口和控制口来实现交互；



