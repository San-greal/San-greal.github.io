---
layout:     post
title:      计组特异点
subtitle:   
date:       2019-10-23
author:     度朝腾
catalog: true
tags:
    - 计组
---

### 一、定点数的表示与运算

1. 47-2：这种题其实并不是考察定点数的乘法运算，在这种题使用乘法运算极度吃亏，相反，考察的是定点数的表示范围，通过转化成十进制，并搞清楚定点数表示的十进制范围，然后通过比较从而判断是否溢出。

2. 47-3：这题考察了大/小端地址以及数据边界对齐的问题，具体的可以查看178页的解释，注意这道题目中的字节分配，可以看答案明白

3. 48-10：这道题目考察的是对于 0 这个比较特殊的情况，原码、反码、补码和移码的区别，从而根据 0 所存在的形式数量，判断不同数据的存在数量：

   1. 原码[+0] = 00000 和 [-0] = 10000
   2. 补码[+0] = [-0] = 0.0000
   3. 反码[+0] = 0.0000 和 [-0] = 1.1111
   4. 移码[+0] = [-0] = 10000

4. 48-11：考察定点数范围以及你对它的熟练度，知道为什么，才能做，这个我建议去看

   [定点数表示范围分析]: https://www.jianshu.com/p/4bcf48987c1f

5. 49-20：这个描述把我坑了，补码与移码的 0 各自表示时当然唯一，但是它们之间相互比较自然不一样

6. 47-28：这道题比较特别，主要是B选项的问题，x 为正数只是充分条件，比如说 x = 0 就打破了这个当且仅当条件，另外需要注意的是，补码的表示形式全部唯一

7. 50-29：这他娘考的就是符号扩展

8. 50-32：你都不知道模4补码是啥？书上41面，双符号位也称模4补码，具体理解可以看

   [模4补码]: https://www.zybang.com/question/8aef3eaf78e5fa54c98c36fa43c63084.html

   要注意的是，存储模4补码只需要一个符号位，因为任何一个正确的数值，模4补码的两个符号位都是相同的

9. 50-35：注意题目的表述，默认认为描述 -0 这种就是原码和反码了

10. 51-42：考察溢出的判断条件，如果再次出错，建议重新观看42页

11. 51-45：描述很奇怪，之后可能还需要判断，这个描述看来，它给你的是什么，本身的机器码就是什么，而且本身还考察了溢出的判断问题

12. 52-54：在计算机中，主存地址主要都是用无符号数表示，因为主存地址都是正数所以不需要符号位

13. 52-58：这他娘考的就是符号扩展，别想多了

14. 52-59：搞清楚逻辑移位与算术移位的区别

15. 53-2：你需要知道的是，这些转换来转换去，机器码本身是不变的，变化的只是对机器码的解释

16. 54-6：变形补码又称之为双符号位，也叫模4补码

### 二、浮点数的表示与运算

1. 66-6：错的知识点都差不多，需要知道的是，阶码位数越多表示的数范围越大，尾数位数越多表示的精度越高

2. 66-7： ![img](https://gss0.baidu.com/-fo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=c43f37c163224f4a57cc7b1539c7bc6a/024f78f0f736afc30ff57e82bd19ebc4b645125f.jpg) 

   ​		这道题就是没搞清楚基数是啥，基数就是这里面的2咯，一般来说是默认为2，当然，可能改成别的考，另外

   存在几个还没搞清楚咋回事的东西：

   - 基数越大，在运算中尾数右移的可能性越小，运算的精度损失越小
   - 基数大时发生因对阶或尾数溢出需右移及规格化需左移的次数显著减少，运算速度可以提高
   - 基数越大，可以表示的数越多
   - 基数越大，范围越大，但精度变小（数变稀疏，因为乘的时候范围变大了，所以变稀疏了（离散了））

3. 67-10：注意，IEEE 754的规则是隐藏了那一个1，但是你自己的规定没说隐藏，所以你懂的

4. 67-11：没有搞清楚为什么要进行浮点数规格化，其实是为了提高精度的同时，保证数据的唯一性， 在计算机内，对非0值的浮点数，要求尾数的绝对值必须大于基数的倒数（默认小于等于1），这就要求尾数的最高有效位是1，满足这种表示要求的浮点数称为规格化表示，不满足条件的就需要规格化咯。 **按规格化的定义-1/2确实应该是算规格化数，但是在机器实际判断规格化与否（以补码为例）是根据符号位与有效位最高位是否不同老判断的，即认为符号位与有效位最高位不同时才是规格化数，所以-1/2又不算规格化数，而根据定义-1本来不算规格化数，但其补码表示为11.0000，机器识别其是规格化数，所以应该是要站在机器判断的角度看，这两个是特殊情况**，另外这道题a选项有个小问题，就是它现在是补码，你必须先把它化成原码再取绝对值 

5. 67-14：注意国际标准中的尾数编码是原码！

6. 68-29、30、31：定点数是没有舍入概念的，别瞎搞；浮点数舍入有两种情况，对阶和右规格化；舍入不一定产生误差，比如说11.00 -> 11.0就没有产生误差；想要具体搞清楚这几道题，我们需要知道什么是溢出：

   1. 阶码上溢：一个正指数超过了最大允许值时，浮点数发生上溢，若结果是正数，发生正上溢出，若结果是负数，发生负上溢出。这种情况为软件故障，通常要引入溢出故障处理程序处理
   2. 阶码下溢：一个负指数比最小允许值还小时，浮点数发生下溢出。一般机器把下溢出时的值置为0，不发生溢出故障
   3. 尾数溢出：当尾数最高有效位进位时，发生尾数溢出。此时进行右归操作：尾数右移一位，阶码加一，直到尾数不溢出为止。此时只要阶码不发生上溢出，浮点数就不会溢出
   4. 非规格化尾数：当数值部分高位不是一个有效值时（如原码时为0或补码时与符号位相同），此时进行左规操作：尾数左移一位，阶码减一，知道尾数为规格化为止



